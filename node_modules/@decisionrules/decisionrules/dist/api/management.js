"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.testManagementSet = exports.lockRuleAPI = exports.findDependenciesAPI = exports.findDuplicatesAPI = exports.importFolderAPI = exports.exportFolderAPI = exports.deleteTagsAPI = exports.updateTagsAPI = exports.getTagsAPI = exports.getRulesForSpaceAPI = exports.deleteRuleAPI = exports.createRuleAPI = exports.updateRuleAPI = exports.updateRuleStatusAPI = exports.getRuleAPI = void 0;
const enums_1 = require("../defs/enums");
const utils_1 = require("../utils/utils");
const httpClient_1 = require("../utils/httpClient");
const utils_2 = require("../utils/utils");
const MODE = enums_1.SdkMode.API;
function getCategoryUrl(host, category, apiPath, queryParams) {
    try {
        const baseUrl = (0, utils_1.getBaseURL)(host, MODE);
        let path = `/api/${category}/${apiPath.join("/")}`;
        if (queryParams) {
            path += `/?tags=${queryParams.toString().trim()}`;
        }
        return new URL(path, baseUrl);
    }
    catch (e) {
        throw e;
    }
}
function getRuleAPI(options, ruleId, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.RULE, [ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "GET");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.getRuleAPI = getRuleAPI;
function updateRuleStatusAPI(options, ruleId, status, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.RULE, ["status", ruleId, status, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "PUT");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.updateRuleStatusAPI = updateRuleStatusAPI;
function updateRuleAPI(options, ruleId, data, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.RULE, [ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "PUT", data);
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.updateRuleAPI = updateRuleAPI;
function createRuleAPI(options, data) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.RULE, []);
            const response = yield (0, httpClient_1.doCall)(url, headers, "POST", data);
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.createRuleAPI = createRuleAPI;
function deleteRuleAPI(options, ruleId, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.RULE, [ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "DELETE");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.deleteRuleAPI = deleteRuleAPI;
function getRulesForSpaceAPI(options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.SPACE, ["items"]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "GET");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.getRulesForSpaceAPI = getRulesForSpaceAPI;
function getTagsAPI(options, tags) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.TAGS, ["items"], tags);
            const response = yield (0, httpClient_1.doCall)(url, headers, "GET");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.getTagsAPI = getTagsAPI;
function updateTagsAPI(options, ruleId, tags, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.TAGS, [ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "PATCH", tags);
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.updateTagsAPI = updateTagsAPI;
function deleteTagsAPI(options, ruleId, tags, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.TAGS, [ruleId, version !== null && version !== void 0 ? version : ""], tags);
            const response = yield (0, httpClient_1.doCall)(url, headers, "DELETE");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.deleteTagsAPI = deleteTagsAPI;
function exportFolderAPI(options, nodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.FOLDER, ["export", nodeId]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "GET");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.exportFolderAPI = exportFolderAPI;
function importFolderAPI(options, targetNodeId, data) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.FOLDER, ["import", targetNodeId]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "POST", data);
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.importFolderAPI = importFolderAPI;
function findDuplicatesAPI(options, ruleId, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.TOOLS, ["duplicates", ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "GET");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.findDuplicatesAPI = findDuplicatesAPI;
function findDependenciesAPI(options, ruleId, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.TOOLS, ["dependencies", ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "GET");
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.findDependenciesAPI = findDependenciesAPI;
function lockRuleAPI(options, ruleId, data, version) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const headers = (0, utils_2.createHeaders)(options.managementKey);
            const url = getCategoryUrl(options.host, enums_1.MngCategoryEnum.RULE, ["lock", ruleId, version !== null && version !== void 0 ? version : ""]);
            const response = yield (0, httpClient_1.doCall)(url, headers, "PATCH", data);
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
exports.lockRuleAPI = lockRuleAPI;
exports.testManagementSet = {
    getCategoryUrl,
    createHeaders: utils_2.createHeaders
};
//# sourceMappingURL=management.js.map